#!/bin/sh
set -e
# set -x
# Usage: pass in a list of services to configure
# Example: service-conf serf haproxy

# add airstack helpers if they exist:
ERROR_MESSAGE_DEFAULT="[ERROR] service-conf -"
[ -f "/package/airstack/core/airstack-helpers" ] && { . /package/airstack/core/airstack-helpers ;} || { printf "missing airstack-helpers. exiting.\n" && exit 113 ;}

# TODO: use the "state" key in config.json
init() {
  echo "hi"
}

###
# Set up necessary service configs after running the enable var contents.
# Usage: pass in the service name in all lowercase.
###
# run the enable command for a service.
service_enable_pre() {
  set +e
  # don't do anything if blank
  [ -z "$1" ] && return 1

  local service_name; service_name="$1"
  local service_name_upcase; service_name_upcase=$( echo "$1" | tr "[:lower:]" "[:upper:]" )
  local enable_name; enable_name=$(find /service/$service_name/env/* -name '*_ENABLE' | head -n1)
  # local enable_name; enable_name=$(find /service/$service_name/env/* -name '*_ENABLE' | head -n1)

  # TODO: jq deep merge-ish. example of somethin...
  # cat /etc/airstack/runtime.json | jq --argfile socklog_unix /package/airstack/socklog-unix/config.json ' .services + $socklog_unix[]'

  chpst -e /service/$service_name/env -u root eval "$SERVICES$service_name_upcase_ENABLE"
  error_check "failure in service_enable_pre"

  return 0
}

###
# Set up necessary service configs after running the enable var contents.
###
service_enable_post() {
  set +e
  echo "Enabling $SERVICE_NAME"
  [ -e /etc/sv/$SERVICE_NAME/run ] && chmod ug+x /etc/sv/$SERVICE_NAME/run
  [ -e /etc/sv/$SERVICE_NAME/log/run ] && chmod ug+x /etc/sv/$SERVICE_NAME/log/run

  for i in ${TMP_RUNLEVELS:-multi}; do
    [ ! -e /etc/runit/runsvdir/$i/$SERVICE_NAME ] && ln -s /etc/sv/$SERVICE_NAME /etc/runit/runsvdir/$i
  done

  # adding to init.d for service command compatibility
  ln -sf /usr/bin/sv /etc/init.d/$SERVICE_NAME
  return 0
}

service_run_init() {
  set +e

  # don't do anything if blank
  [ -z "$SERVICE_RUN" ] && return 1

  # create runit service dir
  [ ! -e $BASEDIR/$SERVICE_NAME/ ] && mkdir -p $BASEDIR/$SERVICE_NAME/

  # create runit service file
  echo "#!/bin/sh" > $BASEDIR/$SERVICE_NAME/run
  echo "exec 2>&1" >> $BASEDIR/$SERVICE_NAME/run
  echo "socklog-check || exit 1"
  echo "$SERVICE_RUN" >> $BASEDIR/$SERVICE_NAME/run

  if [ "$?" -ne 0 ]; then
    echo "$SERVICE_NAME run script failure.\n" >&2
    exit ${E_BAD_RUN}
  fi

  return 0
}

service_log_init() {
  set +e

  # don't do anything if blank
  [ -z "$SERVICE_LOG" ] && return 1

  # create runit service log dir
  [ ! -e $BASEDIR/$SERVICE_NAME/log/ ] && mkdir -p $BASEDIR/$SERVICE_NAME/log/

  # create runit service log file
  local logdir; logdir="$BASEDIR/$SERVICE_NAME/log/run"
  echo "#!/bin/sh" > "$logdir"
  echo "exec 2>&1" >> "$logdir"
  echo $(eval echo "$SERVICE_LOG") >> "$logdir"

  if [ "$?" -ne 0 ]; then
    echo "$SERVICE_NAME log script failure.\n" >&2
    exit ${E_BAD_RUN}
  fi

  return 0
}

main() {
  # TODO: use /etc/airstack/runtime.json instead of passed in file params
  #   runtime.json contains the combined service vars

  # delete # init "$@"

  # service_settings_load #$SERVICE_SETTINGS
  # main_settings_load #$MAIN_SETTINGS

  # delete  # # Now use core loading functions to bring in the json objects.
  # delete  # /package/airstack/core/json2env-core $MAIN_SETTINGS && \
  # delete  # core_settings_load
  # delete
  # delete  # /package/airstack/core/service-json2env $SERVICE_SETTINGS && \
  # delete  # service_settings_load

  for i in "$@"; do
    service_enable_pre $i
  done

# redo  # service_run_init
# redo  # printf "$SERVICE_NAME run is now:\n"
# redo  # printf "$(cat /etc/sv/$SERVICE_NAME/run)\n"
# redo
# redo  # service_log_init
# redo  # printf "$SERVICE_NAME log is now:\n"
# redo  # printf "$(cat /etc/sv/$SERVICE_NAME/log/run)\n"
# redo
# redo  # service_enable_post
}

main "$@"
