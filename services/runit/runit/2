#!/bin/sh -e

PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

msg() {
    # bold
    printf "\033[1m=> $@\033[m"
}

msg_ok() {
    # bold/green
    printf "\033[1m\033[32m OK\033[m\n"
}

msg_fail() {
    # bold/red
    printf "\033[1m\033[31m FAIL\033[m\n"
}

msg_warn() {
    # bold/yellow
    printf "\033[1m\033[33mWARNING: $@\033[m"
}

## END COMMON HEAD

msg "Initializing Runit Level 2\n"

# defaults to 'multi', but can pass in different runlevel.
# /etc/runit/2 single

TMP_RUNLEVEL=$1
runsvchdir ${TMP_RUNLEVEL:="multi"} >/dev/null

# run in bg
env - PATH=$PATH \
/usr/bin/runsvdir -P /etc/service 'log: ...........................................................................................................................................................................................................................................................................................................................................................................................................' &

msg "Starting /dev/log service in $TMP_RUNLEVEL mode\n"
# /etc/airstack/socklog-unix/enable 2>&1 && msg_ok
/etc/airstack/core/service-conf /etc/airstack/core/config.json /etc/airstack/socklog-unix/config.json 2>&1 && msg_ok

# wait until socklog is up b4 proceeding
# TODO put in healthcheck in check script instead of default
# while sv check socklog-unix >/dev/null && false; do
# sv up socklog-unix >/dev/null
# done

# while socklog-check >/dev/null && false; do
# sv up socklog-unix >/dev/null
# done

# Enable all services in parallel if not in single runlevel. See [TODO service docs] for details.
# TODO:
# - loop through AIRSTACK_RUNTIME_VARS.services
# - for each service, check if it has a "run" command set in the json
#   - compile a new enable script with template header, footer, and the run command
# - if no "run" command, default to the respective enable script
#echo $(for i in $AIRSTACK_SERVICES; do echo /etc/airstack/$i/enable; done) | exec xargs -n1 sh

# If not in runlevel "single", then supervise services.
# When supervised services are added, the default runit command of "start" is called unless otherwise specified in config.json.
# In other words, services can be supervised but not started if the default command is stop.
# TODO: in service-conf, check the "state" key in config.json
if [ "$TMP_RUNLEVEL" != "single" ]; then
	echo $(for i in $AIRSTACK_SERVICES; do echo /etc/airstack/$i/config.json; done) | exec xargs -n1 sh /etc/airstack/core/service-conf /etc/airstack/core/config.json
fi

printf "services currently running:\n"
update-service --list

printf "\nShowing log entries from: /var/log/syslog\n"

# tail syslog in foreground
while true; do 
[ -e /var/log/syslog ] && printf "\n" && tail -n10 -F /var/log/syslog 
#printf '.' && 
sleep 0.1
done
