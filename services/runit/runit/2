#!/bin/sh -e


PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

# add airstack helpers if they exist:
ERROR_MESSAGE_DEFAULT="[ERROR] runit runlevel 2 -"
[ -f "/package/airstack/core/airstack-helpers" ] && { . /package/airstack/core/airstack-helpers ;} || { printf "missing airstack-helpers. exiting.\n" && exit 113 ;}


msg "Initializing Runit Level 2\n"

# defaults to 'multi', but can pass in different runlevel.
# /etc/runit/2 single

set -x;

TMP_RUNLEVEL=$1
runsvchdir ${TMP_RUNLEVEL:="multi"} >/dev/null

# run in bg
env - PATH=$PATH \
/usr/bin/runsvdir -P /etc/service 'log: ...........................................................................................................................................................................................................................................................................................................................................................................................................' &

# wait until socklog is up b4 proceeding
# TODO put in healthcheck in check script instead of default
# while sv check socklog-unix >/dev/null && false; do
# sv up socklog-unix >/dev/null
# done

# while socklog-check >/dev/null && false; do
# sv up socklog-unix >/dev/null
# done

# Enable all services in parallel if not in single runlevel. See [TODO service docs] for details.
# TODO:
# - loop through AIRSTACK_RUNTIME_VARS.services
# - for each service, check if it has a "run" command set in the json
#   - compile a new enable script with template header, footer, and the run command
# - if no "run" command, default to the respective enable script


##########################################################
# NOTES FROM "HOW TO JSON2ENV" SESSION
#
# Directory structure for chpst -e environment vars
# /etc/airstack/
#   runtime.json
#   env/
#     env
#     name
#     role
#     ...
# /service/
#   dropbear/
#     env/
#       dropbear_state
#       dropbear_enable
#       dropbear_disable
#       dropbear_run
#       dropbear_tags           < ["ssh"]
#       dropbear_tags_0         < ssh
#       dropbear_input          < [{"location": "", "port": "22", "protocol": "tcp", "tags": [ "ssh" ]}]
#       dropbear_input_0        < {"location": "", "port": "22", "protocol": "tcp", "tags": [ "ssh" ]}
#       dropbear_input_0_port   < 22
#       dropbear_input_0_tags   < ["ssh"]
#       dropbear_input_0_tags_0 < ssh
#       ...
#   serf/
#     env/
#       serf_state
#       serf_enable
#       ...
#
# Load env vars with ...
# $ chpst -e /package/airstack/env/serivces/dropbear -e /package/airstack/env/services/core
# Note that core is loaded last to prevent service definitions from clobbering it as a best practice.
#
# Handling Arrays and Objects
# Since we don't know if a program would prefer json or verbose env vars, we make both available.
# Nested objects should be fully enumerated and split into env vars at every nesting level.
# See dropbear_input vs dropbear_input_0_tags_0 above. If the value of an object key is an array or object,
# make a <servie>_<key>=<json> env var and then iterate through the json value and create additional
# env vars.
#
# CONVENTIONS:
# - only root level keys of runtime.json are available for interpolation in service vals
#   - e.g. $AIRSTACK_USER_NAME is available for DROPBEAR_ENABLE
# - /package is immutable package repo
# - /command is a location to symlink binaries from the /package dir
# - /service/<service>/env contains runtime service configs
#

# If not in runlevel "single", then supervise services.
# When supervised services are added, the default runit command of "start" is called unless otherwise specified in config.json.
# In other words, services can be supervised but not started if the default command is stop.
# TODO: in service-conf, check the "state" key in config.json


# 1. combine each services config.json into one json object: <SERVICES>
# 2. jq <SERVICES> * core/config.json * AIRSTACK_RUNTIME_VARS > runtime.json
# 3. Use only runtime.json in service-conf
set -x

/command/core-json-deepmerge $(ls /package/airstack/*/config.json) | tee /etc/airstack/runtime.json

[ $(echo $AIRSTACK_RUNTIME_VARS | wc -m) -lt 4 ] && AIRSTACK_RUNTIME_VARS="{}"
echo $AIRSTACK_RUNTIME_VARS | tee /tmp/runtime.json
/command/core-json-deepmerge /etc/airstack/runtime.json /tmp/runtime.json | tee /etc/airstack/runtime'{news}'.json
mv -f /etc/airstack/runtime'{news}'.json /etc/airstack/runtime.json

# Create env files in /etc/airstack/env and /service/<service>/env

/package/airstack/core/json2env-core
/package/airstack/core/json2env-services

msg "Starting /dev/log service in $TMP_RUNLEVEL mode\n"
# /package/airstack/socklog-unix/enable 2>&1 && msg_ok

# chpst -e /etc/airstack/env chpst -e env
# /package/airstack/core/service-conf /package/airstack/core/config.json /package/airstack/socklog-unix/config.json
/package/airstack/core/service-conf socklog-unix 2>&1 && msg_ok
error_check "enabling socklog-unix "

if [ "$TMP_RUNLEVEL" != "single" ]; then
	echo $(for i in $AIRSTACK_SERVICES; do echo /package/airstack/$i/config.json; done) | exec xargs -n1 sh /package/airstack/core/service-conf /package/airstack/core/config.json
fi

printf "services currently running:\n"
update-service --list

printf "\nShowing log entries from: /var/log/syslog\n"

# tail syslog in foreground
while true; do
[ -e /var/log/syslog ] && printf "\n" && tail -n10 -F /var/log/syslog
#printf '.' &&
sleep 0.1
done
